/* This file contains all IDL representations pertaining to the OMG 
 * specification "Extensible and Dynamic Topic Types for DDS" (DDS-XTypes).
 */


#include "dds_rtf2_dcps.idl"


// ===========================================================================
// Representing Types with TypeObject
// ===========================================================================

module DDS { 
    // --- Shared meta-data: -------------------------------------------------

    // All of the kinds of types that exist in the type system
    typedef short TypeKind;

    const TypeKind NO_TYPE          = 0; // sentinel indicating "null" value

    const TypeKind BOOLEAN_TYPE     =  1;
    const TypeKind BYTE_TYPE        =  2;
    const TypeKind INT_16_TYPE      =  3;
    const TypeKind UINT_16_TYPE     =  4;
    const TypeKind INT_32_TYPE      =  5;
    const TypeKind UINT_32_TYPE     =  6;
    const TypeKind INT_64_TYPE      =  7;
    const TypeKind UINT_64_TYPE     =  8;
    const TypeKind FLOAT_32_TYPE    =  9;
    const TypeKind FLOAT_64_TYPE    = 10;
    const TypeKind FLOAT_128_TYPE   = 11;
    const TypeKind CHAR_8_TYPE      = 12;
    const TypeKind CHAR_32_TYPE     = 13;

    const TypeKind ENUMERATION_TYPE = 14;
    const TypeKind BITSET_TYPE      = 15;
    const TypeKind ALIAS_TYPE       = 16;

    const TypeKind ARRAY_TYPE       = 17;
    const TypeKind SEQUENCE_TYPE    = 18;
    const TypeKind STRING_TYPE      = 19;
    const TypeKind MAP_TYPE         = 20;

    const TypeKind UNION_TYPE       = 21;
    const TypeKind STRUCTURE_TYPE   = 22;
    const TypeKind ANNOTATION_TYPE  = 23;

    // The name of some element (e.g. type, type member, module)
    const long ELEMENT_NAME_MAX_LENGTH = 256;
    typedef string<ELEMENT_NAME_MAX_LENGTH> ObjectName;

    // Every type has an ID. Those of the primitive types are pre-defined.

    typedef short PrimitiveTypeId;
    
    const PrimitiveTypeId NO_TYPE_ID        = NO_TYPE;
    const PrimitiveTypeId BOOLEAN_TYPE_ID   = BOOLEAN_TYPE;
    const PrimitiveTypeId BYTE_TYPE_ID      = BYTE_TYPE;
    const PrimitiveTypeId INT_16_TYPE_ID    = INT_16_TYPE;
    const PrimitiveTypeId UINT_16_TYPE_ID   = UINT_16_TYPE;
    const PrimitiveTypeId INT_32_TYPE_ID    = INT_32_TYPE;
    const PrimitiveTypeId UINT_32_TYPE_ID   = UINT_32_TYPE;
    const PrimitiveTypeId INT_64_TYPE_ID    = INT_64_TYPE;
    const PrimitiveTypeId UINT_64_TYPE_ID   = UINT_64_TYPE;
    const PrimitiveTypeId FLOAT_32_TYPE_ID  = FLOAT_32_TYPE;
    const PrimitiveTypeId FLOAT_64_TYPE_ID  = FLOAT_64_TYPE;
    const PrimitiveTypeId FLOAT_128_TYPE_ID = FLOAT_128_TYPE;
    const PrimitiveTypeId CHAR_8_TYPE_ID    = CHAR_8_TYPE;
    const PrimitiveTypeId CHAR_32_TYPE_ID   = CHAR_32_TYPE;
    
    union _TypeId switch (TypeKind) {
        case BOOLEAN_TYPE:
        case BYTE_TYPE:
        case INT_16_TYPE:
        case UINT_16_TYPE:
        case INT_32_TYPE:
        case UINT_32_TYPE:
        case INT_64_TYPE:
        case UINT_64_TYPE:
        case FLOAT_32_TYPE:
        case FLOAT_64_TYPE:
        case FLOAT_128_TYPE:
        case CHAR_8_TYPE:
        case CHAR_32_TYPE:
            PrimitiveTypeId primitive_type_id;
        default:
            unsigned long long constructed_type_id;
    };
    
    typedef sequence<_TypeId> TypeIdSeq;


    // --- Annotation usage: -------------------------------------------------

    // ID of a type member
    typedef unsigned long MemberId;
    const MemberId MEMBER_ID_INVALID = 0x0FFFFFFF;

    /* Literal value of an annotation member: either the default value in its
     * definition or the value applied in its usage.
     */
    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    union AnnotationMemberValue switch (TypeKind) {
        case BOOLEAN_TYPE:
            boolean boolean_value;
        case BYTE_TYPE:
            octet byte_value;
        case INT_16_TYPE:
            short int_16_value;
        case UINT_16_TYPE:
            unsigned short uint_16_value;
        case INT_32_TYPE:
            long int_32_value;
        case UINT_32_TYPE:
            unsigned long uint_32_value;
        case INT_64_TYPE:
            long long int_64_value;
        case UINT_64_TYPE:
            unsigned long long uint_64_value;
        case FLOAT_32_TYPE:
            float float_32_value;
        case FLOAT_64_TYPE:
            double float_64_value;
        case FLOAT_128_TYPE:
            long double float_128_value;
        case CHAR_8_TYPE:
            char character_value;
        case CHAR_32_TYPE:
            wchar wide_character_value;
        case ENUMERATION_TYPE:
            long enumeration_value;
        case STRING_TYPE:
            wstring string_value;   // use wide str regardless of char width
    };

    // The assignment of a value to a member of an annotation
    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct AnnotationUsageMember {
        MemberId member_id;             // member of the annotation type
        AnnotationMemberValue value;    // value that member is set to
    };

    typedef sequence<AnnotationUsageMember> AnnotationUsageMemberSeq;

    // The application of an annotation to some type or type member
    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct AnnotationUsage {
        _TypeId type_id;
        AnnotationUsageMemberSeq member;
    };

    typedef sequence<AnnotationUsage> AnnotationUsageSeq;


    // --- Type base class: --------------------------------------------------

    // Flags that apply to type definitions
    @BitSet @BitBound(16)
    enum TypeFlag {
        @Value(0) IS_FINAL,     // | can't both
        @Value(1) IS_MUTABLE,   // | be '1'
        @Value(2) IS_NESTED
    };

    // Fundamental properties of any type definition
    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct TypeProperty {
        TypeFlag flag;
        _TypeId type_id;
        ObjectName name;
    };

    // Member IDs used in the Type base type
    enum TypeMemberId {
        @Value(0) PROPERTY_TYPE_MEMBER_ID,
        @Value(1) ANNOTATION_TYPE_MEMBER_ID
    };

    // Base type for all type definitions
    @Extensibility(MUTABLE_EXTENSIBILITY) @Nested
    struct Type {
        @ID(PROPERTY_TYPE_MEMBER_ID)   TypeProperty property;
        @ID(ANNOTATION_TYPE_MEMBER_ID) AnnotationUsageSeq annotation;
    };


    // --- Aggregations: -----------------------------------------------------

    // Flags that apply to aggregation type members
    @BitSet @BitBound(16)
    enum MemberFlag {
        @Value(0) IS_KEY,
        @Value(1) IS_OPTIONAL,
        @Value(2) IS_SHAREABLE,
        @Value(3) IS_UNION_DEFAULT  // set if member is union default case
    };

    // Fundamental properties of any aggregation type member
    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct MemberProperty {
        MemberFlag flag;
        MemberId member_id;
        _TypeId type_id;
        ObjectName name;
    };

    // Member IDs used in the Member base type
    enum MemberMemberId {
        @Value(0) PROPERTY_MEMBER_MEMBER_ID,
        @Value(1) ANNOTATION_MEMBER_MEMBER_ID
    };

    // Member of an aggregation type
    @Extensibility(MUTABLE_EXTENSIBILITY) @Nested
    struct Member {
        @ID(PROPERTY_MEMBER_MEMBER_ID)   MemberProperty property;
        @ID(ANNOTATION_MEMBER_MEMBER_ID) AnnotationUsageSeq annotation;
    };

    typedef sequence<Member> MemberSeq;

    // Member IDs used in the StructureType type
    enum StructureTypeMemberId {
        @Value(100) BASE_TYPE_STRUCTURETYPE_MEMBER_ID,
        @Value(101) MEMBER_STRUCTURETYPE_MEMBER_ID
    };

    @Extensibility(MUTABLE_EXTENSIBILITY) @Nested
    struct StructureType : Type {
        @ID(BASE_TYPE_STRUCTURETYPE_MEMBER_ID) _TypeId base_type;
        @ID(MEMBER_STRUCTURETYPE_MEMBER_ID)    MemberSeq member;
    };

    // Case labels that apply to a member of a union type
    typedef sequence<long> UnionCaseLabelSeq;

    // Member IDs used in the UnionMember type
    enum UnionMemberMemberId {
        @Value(100) LABEL_UNIONMEMBER_MEMBER_ID
    };

    // Member of a union type
    @Extensibility(MUTABLE_EXTENSIBILITY) @Nested
    struct UnionMember : Member {
        @ID(LABEL_UNIONMEMBER_MEMBER_ID) UnionCaseLabelSeq label;
    };

    typedef sequence<UnionMember> UnionMemberSeq;

    // Member IDs used in the UnionType type
    enum UnionTypeMemberId {
        @Value(100) MEMBER_UNIONTYPE_MEMBER_ID
    };

    @Extensibility(MUTABLE_EXTENSIBILITY) @Nested
    struct UnionType : Type {
        @ID(MEMBER_UNIONTYPE_MEMBER_ID) UnionMemberSeq member;
    };

    // Member IDs used in the AnnotationMember type
    enum AnnotationMemberMemberId {
        @Value(100) DEFAULT_VALUE_ANNOTATIONMEMBER_MEMBER_ID
    };

    // Member of an annotation type
    @Extensibility(MUTABLE_EXTENSIBILITY) @Nested
    struct AnnotationMember : Member {
        @ID(DEFAULT_VALUE_ANNOTATIONMEMBER_MEMBER_ID)
        AnnotationMemberValue default_value;
    };

    typedef sequence<AnnotationMember> AnnotationMemberSeq;

    // Member IDs used in the AnnotationType type
    enum AnnotationTypeMemberId {
        @Value(100) BASE_TYPE_ANNOTATIONTYPE_MEMBER_ID,
        @Value(101) MEMBER_ANNOTATIONTYPE_MEMBER_ID
    };

    @Extensibility(MUTABLE_EXTENSIBILITY) @Nested
    struct AnnotationType : Type {
        @ID(BASE_TYPE_ANNOTATIONTYPE_MEMBER_ID) _TypeId base_type;
        @ID(MEMBER_ANNOTATIONTYPE_MEMBER_ID)    AnnotationMemberSeq member;
    };


    // --- Alias: ------------------------------------------------------------

    // Member IDs used in the AliasType type
    enum AliasTypeMemberId {
        @Value(100) BASE_TYPE_ALIASTYPE_MEMBER_ID
    };

    @Extensibility(MUTABLE_EXTENSIBILITY) @Nested
    struct AliasType : Type {
        @ID(BASE_TYPE_ALIASTYPE_MEMBER_ID) _TypeId base_type;
    };


    // --- Collections: ------------------------------------------------------

    // Bound of a collection type
    typedef unsigned long Bound;
    typedef sequence<Bound> BoundSeq;
    const Bound UNBOUNDED_COLLECTION = 0;

    // Member IDs used in the CollectionType base type
    enum CollectionTypeMemberId {
        @Value(100) ELEMENT_TYPE_COLLECTIONTYPE_MEMBER_ID,
        @Value(101) ELEMENT_SHARED_COLLECTIONTYPE_MEMBER_ID
    };

    // Base type for collection types
    @Extensibility(MUTABLE_EXTENSIBILITY) @Nested
    struct CollectionType : Type {
        @ID(ELEMENT_TYPE_COLLECTIONTYPE_MEMBER_ID) _TypeId element_type;
        @ID(ELEMENT_SHARED_COLLECTIONTYPE_MEMBER_ID) boolean element_shared;
    };

    // Member IDs used in the ArrayType type
    enum ArrayTypeMemberId {
        @Value(200) BOUND_ARRAYTYPE_MEMBER_ID
    };

    @Extensibility(MUTABLE_EXTENSIBILITY) @Nested
    struct ArrayType : CollectionType {
        @ID(BOUND_ARRAYTYPE_MEMBER_ID) BoundSeq bound;
    };

    // Member IDs used in the MapType type
    enum MapTypeMemberId {
        @Value(200) KEY_ELEMENT_TYPE_MAPTYPE_MEMBER_ID,
        @Value(201) BOUND_MAPTYPE_MEMBER_ID
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct MapType : CollectionType {
        @ID(KEY_ELEMENT_TYPE_MAPTYPE_MEMBER_ID) _TypeId key_element_type;
        @ID(BOUND_MAPTYPE_MEMBER_ID)            Bound bound;
    };

    // Member IDs used in the SequenceType type
    enum SequenceTypeMemberId {
        @Value(200) BOUND_SEQUENCETYPE_MEMBER_ID
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct SequenceType : CollectionType {
        @ID(BOUND_SEQUENCETYPE_MEMBER_ID) Bound bound;
    };

    // Member IDs used in the StringType type
    enum StringTypeMemberId {
        @Value(200) BOUND_STRINGTYPE_MEMBER_ID
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct StringType : CollectionType {
        @ID(BOUND_STRINGTYPE_MEMBER_ID) Bound bound;
    };


    // --- Bit set: ----------------------------------------------------------

    // Bit in a bit set
    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct Bit {
        long index;
        ObjectName name;
    };
    
    typedef sequence<Bit> BitSeq;

    // Member IDs used in the BitSetType type
    enum BitSetTypeMemberId {
        @Value(100) BIT_BOUND_BITSETTYPE_MEMBER_ID,
        @Value(101) BIT_BITSETTYPE_MEMBER_ID
    };

    @Extensibility(MUTABLE_EXTENSIBILITY) @Nested
    struct BitSetType : Type {
        @ID(BIT_BOUND_BITSETTYPE_MEMBER_ID) Bound bit_bound;
        @ID(BIT_BITSETTYPE_MEMBER_ID)       BitSeq bit;
    };


    // --- Enumeration: ------------------------------------------------------

    // Constant in an enumeration type
    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct EnumeratedConstant {
        long value;
        ObjectName name;
    };
    
    typedef sequence<EnumeratedConstant> EnumeratedConstantSeq;

    // Member IDs used in the EnumerationType type
    enum EnumerationTypeMemberId {
        @Value(100) BIT_BOUND_ENUMERATIONTYPE_MEMBER_ID,
        @Value(101) CONSTANT_ENUMERATIONTYPE_MEMBER_ID
    };

    // Enumeration type
    @Extensibility(MUTABLE_EXTENSIBILITY) @Nested
    struct EnumerationType : Type {
        @ID(BIT_BOUND_ENUMERATIONTYPE_MEMBER_ID)
        Bound bit_bound;
        @ID(CONSTANT_ENUMERATIONTYPE_MEMBER_ID)
        EnumeratedConstantSeq constant;
    };


    // --- Module: -----------------------------------------------------------

    struct TypeLibrary;

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct _Module {
        ObjectName name;
        @Shared TypeLibrary library;
    };


    // --- Type library: -----------------------------------------------------

    // All of the kinds of definitions that can exist in a type library
    @BitBound(16)
    enum TypeLibraryElementKind {
        @Value(ALIAS_TYPE)       ALIAS_TYPE_ELEMENT,
        @Value(ANNOTATION_TYPE)  ANNOTATION_TYPE_ELEMENT,
        @Value(ARRAY_TYPE)       ARRAY_TYPE_ELEMENT,
        @Value(BITSET_TYPE)      BITSET_TYPE_ELEMENT,
        @Value(ENUMERATION_TYPE) ENUMERATION_TYPE_ELEMENT,
        @Value(MAP_TYPE)         MAP_TYPE_ELEMENT,
        @Value(SEQUENCE_TYPE)    SEQUENCE_TYPE_ELEMENT,
        @Value(STRING_TYPE)      STRING_TYPE_ELEMENT,
        @Value(STRUCTURE_TYPE)   STRUCTURE_TYPE_ELEMENT,
        @Value(UNION_TYPE)       UNION_TYPE_ELEMENT,

        /*auto-assigned value*/  MODULE_ELEMENT
    };

    // Element that can appear in a type library or module: a type or module
    @Extensibility(MUTABLE_EXTENSIBILITY) @Nested
    union TypeLibraryElement switch (TypeLibraryElementKind) {
        case ALIAS_TYPE_ELEMENT:
            AliasType alias_type;
        case ANNOTATION_TYPE_ELEMENT:
            AnnotationType annotation_type;
        case ARRAY_TYPE_ELEMENT:
            ArrayType array_type;
        case BITSET_TYPE_ELEMENT:
            BitSetType bitset_type;
        case ENUMERATION_TYPE_ELEMENT:
            EnumerationType enumeration_type;
        case MAP_TYPE_ELEMENT:
            MapType map_type;
        case SEQUENCE_TYPE_ELEMENT:
            SequenceType sequence_type;
        case STRING_TYPE_ELEMENT:
            StringType string_type;
        case STRUCTURE_TYPE_ELEMENT:
            StructureType structure_type;
        case UNION_TYPE_ELEMENT:
            UnionType union_type;
        case MODULE_ELEMENT:
            _Module mod;
    };

    typedef sequence<TypeLibraryElement> TypeLibraryElementSeq;

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct TypeLibrary {
        TypeLibraryElementSeq element;
    };

    /* Central type of this Type Representation: identifies a single type
     * within a library.
     */
    @Extensibility(MUTABLE_EXTENSIBILITY)
    struct TypeObject {
        @Shared   TypeLibrary library;
        TypeIdSeq the_type;
    };
};  // end module DDS


// ===========================================================================
// Dynamic Language Binding
// ===========================================================================

module DDS {
    local interface DynamicType;
    local interface DynamicTypeBuilder;
    valuetype TypeDescriptor;

    typedef sequence<string> IncludePathSeq;

    local interface DynamicTypeBuilderFactory {
        /*static*/ DynamicTypeBuilderFactory get_instance();
        /*static*/ DDS::ReturnCode_t delete_instance();

        DynamicType get_primitive_type(in TypeKind kind);
        DynamicTypeBuilder create_type(in TypeDescriptor descriptor);
        DynamicTypeBuilder create_type_copy(in DynamicType type);
        DynamicTypeBuilder create_type_w_type_object(
            in TypeObject type_object);
        DynamicTypeBuilder create_string_type(in unsigned long bound);
        DynamicTypeBuilder create_wstring_type(in unsigned long bound);
        DynamicTypeBuilder create_sequence_type(
            in DynamicType element_type,
            in unsigned long bound);
        DynamicTypeBuilder create_array_type(
            in DynamicType element_type,
            in BoundSeq bound);
        DynamicTypeBuilder create_map_type(
            in DynamicType key_element_type,
            in DynamicType element_type,
            in unsigned long bound);
        DynamicTypeBuilder create_bitset_type(in unsigned long bound);
        DynamicTypeBuilder create_type_w_uri(
            in string document_url,
            in string type_name,
            in IncludePathSeq include_paths);
        DynamicTypeBuilder create_type_w_document(
            in string document,
            in string type_name,
            in IncludePathSeq include_paths);
        DDS::ReturnCode_t delete_type(in DynamicType type);
    };

    interface TypeSupport {
    //  ReturnCode_t register_type(
    //      in DomainParticipant domain, 
    //      in string type_name);
    //  string get_type_name();

    //  DynamicType get_type();
    };

    /* Implied IDL for type "Foo":
    interface FooTypeSupport : DDS::TypeSupport {
        DDS::ReturnCode_t register_type(
            in DDS::DomainParticipant participant, 
            in string type_name);
        string get_type_name();

        DynamicType get_type();

        Foo create_sample(in DynamicData src);
        DynamicData create_dynamic_sample(in Foo src);
    };
    */

    interface DynamicTypeSupport : TypeSupport {
        /* This interface shall instantiate the type FooTypeSupport 
         * defined by the DDS specification where "Foo" is DynamicData.
         */

        /*static*/ DynamicTypeSupport create_type_support(
            in DynamicType type);
        /*static*/ DDS::ReturnCode_t delete_type_support(
            in DynamicTypeSupport type_support);

        DDS::ReturnCode_t register_type(
            in DDS::DomainParticipant participant,
            in ObjectName type_name);
        ObjectName get_type_name();
    };

    typedef map<ObjectName, ObjectName> Parameters;

    valuetype AnnotationDescriptor  {
        public DynamicType type;

        DDS::ReturnCode_t get_value(
            inout ObjectName value, in ObjectName key);
        DDS::ReturnCode_t get_all_value(
            inout Parameters value);
        DDS::ReturnCode_t set_value(
            in ObjectName key, in ObjectName value);

        DDS::ReturnCode_t copy_from(in AnnotationDescriptor other);
        boolean equals(in AnnotationDescriptor other);
        boolean is_consistent();
    };

    valuetype TypeDescriptor {
        public TypeKind kind;
        public ObjectName name;
        public DynamicType base_type;
        public DynamicType discriminator_type;
        public BoundSeq bound;
        @Optional public DynamicType element_type;
        @Optional public DynamicType key_element_type;

        DDS::ReturnCode_t copy_from(in TypeDescriptor other);
        boolean equals(in TypeDescriptor other);
        boolean is_consistent();
    };

    valuetype MemberDescriptor  {
        public ObjectName name;
        public MemberId id;
        public DynamicType type;
        public string default_value;
        public unsigned long index;
        public UnionCaseLabelSeq label;
        public boolean default_label;

        DDS::ReturnCode_t copy_from(in MemberDescriptor descriptor);
        boolean equals(in MemberDescriptor descriptor);
        boolean is_consistent();
    };

    local interface DynamicTypeMember {
        DDS::ReturnCode_t get_descriptor(
            inout MemberDescriptor descriptor);

        unsigned long get_annotation_count();
        DDS::ReturnCode_t get_annotation(
            inout AnnotationDescriptor descriptor,
            in unsigned long idx);

        boolean equals(in DynamicTypeMember other);

        MemberId get_id();
        ObjectName get_name();
    };

    typedef map<ObjectName, DynamicTypeMember> DynamicTypeMembersByName;
    typedef map<MemberId, DynamicTypeMember>   DynamicTypeMembersById;

    local interface DynamicTypeBuilder {
        DDS::ReturnCode_t get_descriptor(
            inout TypeDescriptor descriptor);

        ObjectName get_name();
        TypeKind get_kind();

        DDS::ReturnCode_t get_member_by_name(
            inout DynamicTypeMember member,
            in ObjectName name);
        DDS::ReturnCode_t get_all_members_by_name(
            inout DynamicTypeMembersByName member);

        DDS::ReturnCode_t get_member(
            inout DynamicTypeMember member,
            in MemberId id);
        DDS::ReturnCode_t get_all_members(
            inout DynamicTypeMembersById member);

        unsigned long get_annotation_count();
        DDS::ReturnCode_t get_annotation(
            inout AnnotationDescriptor descriptor,
            in unsigned long idx);

        boolean equals(in DynamicType other);
        DDS::ReturnCode_t add_member(in MemberDescriptor descriptor);
        DDS::ReturnCode_t apply_annotation(
            in AnnotationDescriptor descriptor);

        DynamicType build();
    };

    local interface DynamicType {
        DDS::ReturnCode_t get_descriptor(
            inout TypeDescriptor descriptor);

        ObjectName get_name();
        TypeKind get_kind();

        DDS::ReturnCode_t get_member_by_name(
            inout DynamicTypeMember member,
            in ObjectName name);
        DDS::ReturnCode_t get_all_members_by_name(
            inout DynamicTypeMembersByName member);

        DDS::ReturnCode_t get_member(
            inout DynamicTypeMember member,
            in MemberId id);
        DDS::ReturnCode_t get_all_members(
            inout DynamicTypeMembersById member);

        unsigned long get_annotation_count();
        DDS::ReturnCode_t get_annotation(
            inout AnnotationDescriptor descriptor,
            in unsigned long idx);

        boolean equals(in DynamicType other);
    };

    local interface DynamicData;

    local interface DynamicDataFactory  {
        /*static*/ DynamicDataFactory get_instance();
        /*static*/ DDS::ReturnCode_t delete_instance();

        DynamicData create_data();
        DDS::ReturnCode_t delete_data(in DynamicData data);
    };

    typedef sequence<long>                  Int32Seq;
    typedef sequence<unsigned long>         UInt32Seq;
    typedef sequence<short>                 Int16Seq;
    typedef sequence<unsigned short>        UInt16Seq;
    typedef sequence<long long>             Int64Seq;
    typedef sequence<unsigned long long>    UInt64Seq;
    typedef sequence<float>                 Float32Seq;
    typedef sequence<double>                Float64Seq;
    typedef sequence<long double>           Float128Seq;
    typedef sequence<char>                  CharSeq;
    typedef sequence<wchar>                 WcharSeq;
    typedef sequence<boolean>               BooleanSeq;
    typedef sequence<octet>                 ByteSeq;

    // typedef sequence<string>             StringSeq;
    typedef sequence<wstring>               WstringSeq;

    local interface DynamicData {
        readonly attribute DynamicType type;

        DDS::ReturnCode_t get_descriptor(
            inout MemberDescriptor value,
            in MemberId id);
        DDS::ReturnCode_t set_descriptor(
            in MemberId id,
            in MemberDescriptor value);

        boolean equals(in DynamicData other);

        MemberId get_member_id_by_name(in ObjectName name);
        MemberId get_member_id_at_index(in unsigned long index);

        unsigned long get_item_count();

        DDS::ReturnCode_t clear_all_values();
        DDS::ReturnCode_t clear_nonkey_values();
        DDS::ReturnCode_t clear_value(in MemberId id);

        DynamicData loan_value(in MemberId id);
        DDS::ReturnCode_t return_loaned_value(in DynamicData value);

        DynamicData clone();

        DDS::ReturnCode_t get_int32_value(
            inout long value,
            in MemberId id);
        DDS::ReturnCode_t set_int32_value(
            in MemberId id,
            in long value);
        DDS::ReturnCode_t get_uint32_value(
            inout unsigned long value,
            in MemberId id);
        DDS::ReturnCode_t set_uint32_value(
            in MemberId id,
            in unsigned long value);
        DDS::ReturnCode_t get_int16_value(
            inout short value,
            in MemberId id);
        DDS::ReturnCode_t set_int16_value(
            in MemberId id,
            in short value);
        DDS::ReturnCode_t get_uint16_value(
            inout unsigned short value,
            in MemberId id);
        DDS::ReturnCode_t set_uint16_value(
            in MemberId id,
            in unsigned short value);
        DDS::ReturnCode_t get_int64_value(
            inout long long value,
            in MemberId id);
        DDS::ReturnCode_t set_int64_value(
            in MemberId id,
            in long long value);
        DDS::ReturnCode_t get_uint64_value(
            inout unsigned long long value,
            in MemberId id);
        DDS::ReturnCode_t set_uint64_value(
            in MemberId id,
            in unsigned long long value);
        DDS::ReturnCode_t get_float32_value(
            inout float value,
            in MemberId id);
        DDS::ReturnCode_t set_float32_value(
            in MemberId id,
            in float value);
        DDS::ReturnCode_t get_float64_value(
            inout double value,
            in MemberId id);
        DDS::ReturnCode_t set_float64_value(
            in MemberId id,
            in double value);
        DDS::ReturnCode_t get_float128_value(
            inout long double value,
            in MemberId id);
        DDS::ReturnCode_t set_float128_value(
            in MemberId id,
            in long double value);
        DDS::ReturnCode_t get_char8_value(
            inout char value,
            in MemberId id);
        DDS::ReturnCode_t set_char8_value(
            in MemberId id,
            in char value);
        DDS::ReturnCode_t get_char32_value(
            inout wchar value,
            in MemberId id);
        DDS::ReturnCode_t set_char32_value(
            in MemberId id,
            in wchar value);
        DDS::ReturnCode_t get_byte_value(
            inout octet value,
            in MemberId id);
        DDS::ReturnCode_t set_byte_value(
            in MemberId id,
            in octet value);
        DDS::ReturnCode_t get_boolean_value(
            inout boolean value,
            in MemberId id);
        DDS::ReturnCode_t set_boolean_value(
            in MemberId id,
            in boolean value);
        DDS::ReturnCode_t get_string_value(
            inout string value,
            in MemberId id);
        DDS::ReturnCode_t set_string_value(
            in MemberId id,
            in string value);
        DDS::ReturnCode_t get_wstring_value(
            inout wstring value,
            in MemberId id);
        DDS::ReturnCode_t set_wstring_value(
            in MemberId id,
            in wstring value);

        DDS::ReturnCode_t get_complex_value(
            inout DynamicData value,
            in MemberId id);
        DDS::ReturnCode_t set_complex_value(
            in MemberId id,
            in DynamicData value);

        DDS::ReturnCode_t get_int32_values(
            inout Int32Seq value,
            in MemberId id);
        DDS::ReturnCode_t set_int32_values(
            in MemberId id,
            in Int32Seq value);
        DDS::ReturnCode_t get_uint32_values(
            inout UInt32Seq value,
            in MemberId id);
        DDS::ReturnCode_t set_uint32_values(
            in MemberId id,
            in UInt32Seq value);
        DDS::ReturnCode_t get_int16_values(
            inout Int16Seq value,
            in MemberId id);
        DDS::ReturnCode_t set_int16_values(
            in MemberId id,
            in Int16Seq value);
        DDS::ReturnCode_t get_uint16_values(
            inout UInt16Seq value,
            in MemberId id);
        DDS::ReturnCode_t set_uint16_values(
            in MemberId id,
            in UInt16Seq value);
        DDS::ReturnCode_t get_int64_values(
            inout Int64Seq value,
            in MemberId id);
        DDS::ReturnCode_t set_int64_values(
            in MemberId id,
            in Int64Seq value);
        DDS::ReturnCode_t get_uint64_values(
            inout UInt64Seq value,
            in MemberId id);
        DDS::ReturnCode_t set_uint64_values(
            in MemberId id,
            in UInt64Seq value);
        DDS::ReturnCode_t get_float32_values(
            inout Float32Seq value,
            in MemberId id);
        DDS::ReturnCode_t set_float32_values(
            in MemberId id,
            in Float32Seq value);
        DDS::ReturnCode_t get_float64_values(
            inout Float64Seq value,
            in MemberId id);
        DDS::ReturnCode_t set_float64_values(
            in MemberId id,
            in Float64Seq value);
        DDS::ReturnCode_t get_float128_values(
            inout Float128Seq value,
            in MemberId id);
        DDS::ReturnCode_t set_float128_values(
            in MemberId id,
            in Float128Seq value);
        DDS::ReturnCode_t get_char8_values(
            inout CharSeq value,
            in MemberId id);
        DDS::ReturnCode_t set_char8_values(
            in MemberId id,
            in CharSeq value);
        DDS::ReturnCode_t get_char32_values(
            inout WcharSeq value,
            in MemberId id);
        DDS::ReturnCode_t set_char32_values(
            in MemberId id,
            in WcharSeq value);
        DDS::ReturnCode_t get_byte_values(
            inout ByteSeq value,
            in MemberId id);
        DDS::ReturnCode_t set_byte_values(
            in MemberId id,
            in ByteSeq value);
        DDS::ReturnCode_t get_boolean_values(
            inout BooleanSeq value,
            in MemberId id);
        DDS::ReturnCode_t set_boolean_values(
            in MemberId id,
            in BooleanSeq value);
        DDS::ReturnCode_t get_string_values(
            inout StringSeq value,
            in MemberId id);
        DDS::ReturnCode_t set_string_values(
            in MemberId id,
            in StringSeq value);
        DDS::ReturnCode_t get_wstring_values(
            inout WstringSeq value,
            in MemberId id);
        DDS::ReturnCode_t set_wstring_values(
            in MemberId id,
            in WstringSeq value);
    };  // local interface DynamicData
};  // end module DDS


// ===========================================================================
// DDS Built-in Topic Data Types
// ===========================================================================

module DDS {
    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct BuiltinTopicKey_t {
        long value[4];
    };

    @Extensibility(FINAL_EXTENSIBILITY) @Nested
    struct Duration_t {
        long sec;
        unsigned long nanosec;
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct DeadlineQosPolicy {
        Duration_t period;
    };

    enum DestinationOrderQosPolicyKind {
        BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS,
        BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct DestinationOrderQosPolicy {
        DestinationOrderQosPolicyKind kind;
    };

    enum DurabilityQosPolicyKind {
        VOLATILE_DURABILITY_QOS,
        TRANSIENT_LOCAL_DURABILITY_QOS,
        TRANSIENT_DURABILITY_QOS,
        PERSISTENT_DURABILITY_QOS
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct DurabilityQosPolicy {
        DurabilityQosPolicyKind kind;
    };

    enum HistoryQosPolicyKind {
        KEEP_LAST_HISTORY_QOS,
        KEEP_ALL_HISTORY_QOS
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct HistoryQosPolicy {
        HistoryQosPolicyKind kind;
        long depth;
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct DurabilityServiceQosPolicy {
        Duration_t service_cleanup_delay;
        HistoryQosPolicyKind history_kind;
        long history_depth;
        long max_samples;
        long max_instances;
        long max_samples_per_instance;
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct GroupDataQosPolicy {
        ByteSeq value;
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct LatencyBudgetQosPolicy {
        Duration_t duration;
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct LifespanQosPolicy {
        Duration_t duration;
    };

    enum LivelinessQosPolicyKind {
        AUTOMATIC_LIVELINESS_QOS,
        MANUAL_BY_PARTICIPANT_LIVELINESS_QOS,
        MANUAL_BY_TOPIC_LIVELINESS_QOS
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct LivelinessQosPolicy {
        LivelinessQosPolicyKind kind;
        Duration_t lease_duration;
    };

    enum OwnershipQosPolicyKind {
        SHARED_OWNERSHIP_QOS,
        EXCLUSIVE_OWNERSHIP_QOS
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct OwnershipQosPolicy {
        OwnershipQosPolicyKind kind;
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct OwnershipStrengthQosPolicy {
        long value;
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct PartitionQosPolicy {
        StringSeq name;
    };

    enum PresentationQosPolicyAccessScopeKind {
        INSTANCE_PRESENTATION_QOS,
        TOPIC_PRESENTATION_QOS,
        GROUP_PRESENTATION_QOS
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct PresentationQosPolicy {
        PresentationQosPolicyAccessScopeKind access_scope;
        boolean coherent_access;
        boolean ordered_access;
    };

    enum ReliabilityQosPolicyKind {
        BEST_EFFORT_RELIABILITY_QOS,
        RELIABLE_RELIABILITY_QOS
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct ReliabilityQosPolicy {
        ReliabilityQosPolicyKind kind;
        Duration_t max_blocking_time;
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct ResourceLimitsQosPolicy {
        long max_samples;
        long max_instances;
        long max_samples_per_instance;
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct TimeBasedFilterQosPolicy {
        Duration_t minimum_separation;
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct TopicDataQosPolicy {
        ByteSeq value;
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct TransportPriorityQosPolicy {
        long value;
    };

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct UserDataQosPolicy {
        ByteSeq value;
    };

    @Extensibility(MUTABLE_EXTENSIBILITY)
    struct ParticipantBuiltinTopicData {
        @ID(0x0050) @Key BuiltinTopicKey_t key;
        @ID(0x002C)      UserDataQosPolicy user_data;
    };

    typedef short DataRepresentationId_t;

    const DataRepresentationId_t XCDR_DATA_REPRESENTATION = 0;
    const DataRepresentationId_t XML_DATA_REPRESENTATION  = 1;

    typedef sequence<DataRepresentationId_t> DataRepresentationIdSeq;

    const QosPolicyId_t DATA_REPRESENTATION_QOS_POLICY_ID = 23;
    const string DATA_REPRESENTATION_QOS_POLICY_NAME = "DataRepresentation";

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct DataRepresentationQosPolicy {
        DataRepresentationIdSeq value;
    };

    @BitBound(16)
    enum TypeConsistencyKind {
        DISALLOW_TYPE_COERCION,
        ALLOW_TYPE_COERCION
    };

    const QosPolicyId_t TYPE_CONSISTENCY_ENFORCEMENT_QOS_POLICY_ID = 24;
    const string TYPE_CONSISTENCY_ENFORCEMENT_QOS_POLICY_NAME =
        "TypeConsistencyEnforcement";

    @Extensibility(EXTENSIBLE_EXTENSIBILITY) @Nested
    struct TypeConsistencyEnforcementQosPolicy {
        TypeConsistencyKind kind;
    };

    @Extensibility(MUTABLE_EXTENSIBILITY)
    struct TopicBuiltinTopicData {
        @ID(0x005A) @Key BuiltinTopicKey_t key;
        @ID(0x0005)      ObjectName name;
        @ID(0x0007)      ObjectName type_name;
        @ID(0x0075) @Optional   DDS::StringSeq  equivalent_type_name;
        @ID(0x0076) @Optional   DDS::StringSeq  base_type_name;
        @ID(0x0072) @Optional   DDS::TypeObject type;
        @ID(0x001D)      DurabilityQosPolicy durability;
        @ID(0x001E)      DurabilityServiceQosPolicy durability_service;
        @ID(0x0023)      DeadlineQosPolicy deadline;
        @ID(0x0027)      LatencyBudgetQosPolicy latency_budget;
        @ID(0x001B)      LivelinessQosPolicy liveliness;
        @ID(0x001A)      ReliabilityQosPolicy reliability;
        @ID(0x0049)      TransportPriorityQosPolicy transport_priority;
        @ID(0x002B)      LifespanQosPolicy lifespan;
        @ID(0x0025)      DestinationOrderQosPolicy destination_order;
        @ID(0x0040)      HistoryQosPolicy history;
        @ID(0x0041)      ResourceLimitsQosPolicy resource_limits;
        @ID(0x001F)      OwnershipQosPolicy ownership;
        @ID(0x002E)      TopicDataQosPolicy topic_data;
        @ID(0x0073)      DataRepresentationQosPolicy representation;
    };

    @Extensibility(MUTABLE_EXTENSIBILITY)
    struct TopicQos {
        // ...
        DataRepresentationQosPolicy representation;
    };

    @Extensibility(MUTABLE_EXTENSIBILITY)
    struct PublicationBuiltinTopicData {
        @ID(0x005A) @Key BuiltinTopicKey_t key;
        @ID(0x0050)      BuiltinTopicKey_t participant_key;
        @ID(0x0005)      ObjectName topic_name;
        @ID(0x0007)      ObjectName type_name;
        @ID(0x0075) @Optional   DDS::StringSeq  equivalent_type_name;
        @ID(0x0076) @Optional   DDS::StringSeq  base_type_name;
        @ID(0x0072) @Optional   DDS::TypeObject type;
        @ID(0x001D)      DurabilityQosPolicy durability; 
        @ID(0x001E)      DurabilityServiceQosPolicy durability_service;
        @ID(0x0023)      DeadlineQosPolicy deadline;
        @ID(0x0027)      LatencyBudgetQosPolicy latency_budget;
        @ID(0x001B)      LivelinessQosPolicy liveliness;
        @ID(0x001A)      ReliabilityQosPolicy reliability;
        @ID(0x002B)      LifespanQosPolicy lifespan;
        @ID(0x002C)      UserDataQosPolicy user_data;
        @ID(0x001F)      OwnershipQosPolicy ownership;
        @ID(0x0006)      OwnershipStrengthQosPolicy ownership_strength;
        @ID(0x0025)      DestinationOrderQosPolicy destination_order;
        @ID(0x0021)      PresentationQosPolicy presentation; 
        @ID(0x0029)      PartitionQosPolicy partition; 
        @ID(0x002E)      TopicDataQosPolicy topic_data;
        @ID(0x002D)      GroupDataQosPolicy group_data;
        @ID(0x0073)      DataRepresentationQosPolicy representation;
    };

    @Extensibility(MUTABLE_EXTENSIBILITY)
    struct DataWriterQos {
        // ...
        DataRepresentationQosPolicy representation;
    };

    @Extensibility(MUTABLE_EXTENSIBILITY)
    struct SubscriptionBuiltinTopicData {
        @ID(0x005A) @Key BuiltinTopicKey_t key;
        @ID(0x0050)      BuiltinTopicKey_t participant_key;
        @ID(0x0005)      ObjectName topic_name;
        @ID(0x0007)      ObjectName type_name;
        @ID(0x0075) @Optional   DDS::StringSeq  equivalent_type_name;
        @ID(0x0076) @Optional   DDS::StringSeq  base_type_name;
        @ID(0x0072) @Optional   DDS::TypeObject type;
        @ID(0x001D)      DurabilityQosPolicy durability;
        @ID(0x0023)      DeadlineQosPolicy deadline;
        @ID(0x0027)      LatencyBudgetQosPolicy latency_budget;
        @ID(0x001B)      LivelinessQosPolicy liveliness;
        @ID(0x001A)      ReliabilityQosPolicy reliability;
        @ID(0x001F)      OwnershipQosPolicy ownership;
        @ID(0x0025)      DestinationOrderQosPolicy destination_order;
        @ID(0x002C)      UserDataQosPolicy user_data;
        @ID(0x0004)      TimeBasedFilterQosPolicy time_based_filter; 
        @ID(0x0021)      PresentationQosPolicy presentation;
        @ID(0x0029)      PartitionQosPolicy partition;
        @ID(0x002E)      TopicDataQosPolicy topic_data;
        @ID(0x002D)      GroupDataQosPolicy group_data;
        @ID(0x0073)      DataRepresentationQosPolicy representation;
        @ID(0x0074)      TypeConsistencyEnforcementQosPolicy type_consistency;
    };

    @Extensibility(MUTABLE_EXTENSIBILITY)
    struct DataReaderQos {
        // ...
        DataRepresentationQosPolicy representation;
        TypeConsistencyEnforcementQosPolicy type_consistency;
    };
};  // end module DDS


// ===========================================================================
// Built-in Data Types
// ===========================================================================

module DDS {
    @Extensibility(EXTENSIBLE_EXTENSIBILITY)
    struct _String {
        string value;
    };

    interface StringDataWriter : DataWriter {
        /* This interface shall instantiate the type FooDataWriter defined by
         * the DDS specification where "Foo" is an unbounded string.
         */
    };

    interface StringDataReader : DataReader {
        /* This interface shall instantiate the type FooDataReader defined by
         * the DDS specification where "Foo" is an unbounded string.
         */
    };

    interface StringTypeSupport : TypeSupport {
        /* This interface shall instantiate the type FooTypeSupport 
         * defined by the DDS specification where "Foo" is an unbounded 
         * string.
         */
    };


    @Extensibility(EXTENSIBLE_EXTENSIBILITY)
    struct KeyedString {
        @Key string key;
        string value;
    };
    typedef sequence<KeyedString> KeyedStringSeq;

    interface KeyedStringDataWriter : DataWriter {
        /* This interface shall instantiate the type FooDataWriter defined by
         * the DDS specification where "Foo" is KeyedString. It also defines
         * the operations below.
         */
        InstanceHandle_t register_instance_w_key(
            in string key);
        InstanceHandle_t register_instance_w_key_w_timestamp(
            in string key,
            in Time_t source_timestamp);

        ReturnCode_t unregister_instance_w_key(
            in string key);
        ReturnCode_t unregister_instance_w_key_w_timestamp(
            in string key,
            in Time_t source_timestamp);

        ReturnCode_t write_string_w_key(
            in string key,
            in string str,
            in InstanceHandle_t handle);
        ReturnCode_t write_string_w_key_w_timestamp(
            in string key,
            in string str,
            in InstanceHandle_t handle,
            in Time_t source_timestamp);

        ReturnCode_t dispose_w_key(
            in string key);
        ReturnCode_t dispose_w_key_w_timestamp(
            in string key,
            in Time_t source_timestamp);

        ReturnCode_t get_key_value_w_key(
            inout string key,
            in InstanceHandle_t handle);

        InstanceHandle_t lookup_instance_w_key(
            in string key);
    };

    interface KeyedStringDataReader : DataReader {
        /* This interface shall instantiate the type FooDataReader defined by
         * the DDS specification where "Foo" is KeyedString.
         */
    };

    interface KeyedStringTypeSupport : TypeSupport {
        /* This interface shall instantiate the type FooTypeSupport 
         * defined by the DDS specification where "Foo" is KeyedString.
         */
    };


    @Extensibility(EXTENSIBLE_EXTENSIBILITY)
    struct Bytes {
        ByteSeq value;
    };
    typedef sequence<Bytes> BytesSeq;

    interface BytesDataWriter : DataWriter {
        /* This interface shall instantiate the type FooDataWriter defined by
         * the DDS specification where "Foo" is an unbounded sequence of
         * bytes (octets). It also defines the operations below.
         */
        ReturnCode_t write_w_bytes(
              in ByteArray bytes,
              in long offset,
              in long length,
              in InstanceHandle_t handle);
        ReturnCode_t write_w_bytes_w_timestamp(
              in ByteArray bytes,
              in long offset,
              in long length,
              in InstanceHandle_t handle,
              in Time_t source_timestamp);
    };

    interface BytesDataReader : DataReader {
        /* This interface shall instantiate the type FooDataReader defined by
         * the DDS specification where "Foo" is Bytes.
         */
    }; 

    interface BytesTypeSupport : TypeSupport {
        /* This interface shall instantiate the type FooTypeSupport 
         * defined by the DDS specification where "Foo" is Bytes.
         */
    }; 


    @Extensibility(EXTENSIBLE_EXTENSIBILITY)
    struct KeyedBytes {
        @Key string key;
        ByteSeq value;
    };
    typedef sequence<KeyedBytes> KeyedBytesSeq;

    interface KeyedBytesDataWriter : DataWriter {
        /* This interface shall instantiate the type FooDataWriter defined by
         * the DDS specification where "Foo" is KeyedBytes. It also defines
         * It also defines the operations below.
         */
        InstanceHandle_t register_instance_w_key(
            in string key);
        InstanceHandle_t register_instance_w_key_w_timestamp(
            in string key,
            in Time_t source_timestamp);

        ReturnCode_t unregister_instance_w_key(
            in string key);
        ReturnCode_t unregister_instance_w_key_w_timestamp(
            in string key, 
            in Time_t source_timestamp);

        ReturnCode_t write_bytes_w_key(
              in string key,
              in ByteArray bytes,
              in long offset,
              in long length,
              in InstanceHandle_t handle);
        ReturnCode_t write_bytes_w_key_w_timestamp(
              in string key,
              in ByteArray bytes,
              in long offset,
              in long length,
              in InstanceHandle_t handle,
              in Time_t source_timestamp);

        ReturnCode_t dispose_w_key(
            in string key);
        ReturnCode_t dispose_w_key_w_timestamp(
            in string key,
            in Time_t source_timestamp);

        ReturnCode_t get_key_value_w_key(
            inout string key,
            in InstanceHandle_t handle);

        InstanceHandle_t lookup_instance_w_key(
            in string key);
    };

    interface KeyedBytesDataReader : DataReader {
        /* This interface shall instantiate the type FooDataReader defined by
         * the DDS specification where "Foo" is KeyedBytes.
         */
    }; 

    interface KeyedBytesTypeSupport : TypeSupport {
        /* This interface shall instantiate the type FooTypeSupport 
         * defined by the DDS specification where "Foo" is KeyedBytes.
         */
    }; 
};  // end module DDS


// ===========================================================================
// Built-in Annotations
// ===========================================================================

module DDS {
    @Annotation
    local interface ID {
        attribute unsigned long value;
    };

    @Annotation
    local interface Optional {
        attribute boolean value default true;
    };

    @Annotation
    local interface Key {
        attribute boolean value default true;
    };

    @Annotation
    local interface BitBound {
        attribute unsigned short value default 32;
    };

    @Annotation
    local interface Value {
        attribute unsigned long value;
    };

    @Annotation
    local interface BitSet {
    };

    @Annotation
    local interface Nested {
        attribute boolean value default true;
    };

    enum ExtensibilityKind {
        FINAL_EXTENSIBILITY,
        EXTENSIBLE_EXTENSIBILITY,
        MUTABLE_EXTENSIBILITY
    };

    @Annotation
    local interface Extensibility {
        attribute ExtensibilityKind value;
    };

    @Annotation
    local interface MustUnderstand {
        attribute boolean value default true;
    };

    typedef string<32>  VerbatimLanguage;
    typedef string<128> VerbatimPlacement;

    @Annotation
    local interface Verbatim {
        attribute VerbatimLanguage  language    default "*";
        attribute VerbatimPlacement placement   default "before-declaration";
        attribute string            text;
    };

    @Annotation
    local interface Shared {
	    attribute boolean value default true;
    };
};  // end module DDS


// ===========================================================================
// End file
